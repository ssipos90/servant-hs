{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE NamedFieldPuns      #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE TypeOperators       #-}

module Lib
    ( startApp
    ) where
import           Control.Monad.Reader       (MonadIO (liftIO), ReaderT (..),
                                             ask, runReaderT)

import           Control.Exception          (bracket)
import           Data.Aeson                 (FromJSON, defaultOptions)
import           Data.Aeson.TH              (deriveJSON)
import           Data.ByteString            (ByteString)
import           Data.Pool                  (Pool (..), createPool,
                                             withResource)
import           Database.PostgreSQL.Simple (Connection, Only (Only), close,
                                             connectPostgreSQL, execute_, query)
import           GHC.Generics               (Generic (..))
import           Network.Wai
import           Network.Wai.Handler.Warp
import           Servant                    (Handler, HasServer (ServerT),
                                             Proxy (..), ServerT, hoistServer,
                                             serve)
import           Servant.API                (Get, JSON, Post, ReqBody,
                                             (:<|>) (..), (:>))

type DBConnectionString = ByteString

data User = User
  { userId        :: Int
  , userFirstName :: String
  , userLastName  :: String
  } deriving (Eq, Show)

data CreateUser = CreateUser
  { firstName :: String
  , lastName  :: String
  } deriving (Show, Generic)

instance FromJSON CreateUser

$(deriveJSON defaultOptions ''User)

type API = "users" :> (
                        Get '[JSON] [User]
                   :<|> ReqBody '[JSON] CreateUser :> Post '[JSON] User
                      )
                  --  :<|> Capture "userId" Int :> (
                  --         Get '[JSON] User
                  --    :<|> Put '[JSON] User
                  --   )
                  -- )

initDB :: DBConnectionString -> IO ()
initDB connstr = bracket (connectPostgreSQL connstr) close $ \conn -> do
  _ <- execute_ conn
    "CREATE TABLE IF NOT EXISTS messages (msg text not null)"
  _ <- execute_ conn
    "CREATE TABLE IF NOT EXISTS users \
    \( userId INT GENERATED BY DEFAULT AS IDENTITY\
    \, firstName VARCHAR NOT NULL\
    \, lastName VARCHAR NOT NULL\
    \)"
  return ()

data Database = Database {
  pool :: Pool Connection
}

initConnectionPool :: DBConnectionString -> IO (Pool Connection)
initConnectionPool connStr =
  createPool (connectPostgreSQL connStr)
             close
             2 -- stripes
             60 -- unused connections are kept open for a minute
             10 -- max. 10 connections open per stripe

startApp :: IO ()
startApp = do
  let connStr = "host=localhost port=5432 dbname=servant user=postgres password=1q2w3e"
  pool <- initConnectionPool connStr
  initDB connStr
  run 8080 (app $ Database { pool = pool })

app :: Database -> Application
app db = serve api $ hoistServer api (readerToHandler db) server

api :: Proxy API
api = Proxy

readerToHandler :: Database -> ReaderT Database Handler a -> Handler a
readerToHandler db r = runReaderT r db

server :: ServerT API (ReaderT Database Handler)
server = listUsers
  :<|> createUser
  -- :<|> (\userId ->
  --         getUser userId
  --         :<|> updateUser userId
  --       )
  where
    createUser :: CreateUser -> ReaderT Database Handler User
    createUser CreateUser{ firstName, lastName } = do
      Database{ pool } <- ask
      res :: [Only Int] <- liftIO $ withResource pool $ \conn -> query conn "INSERT INTO users (firstName, lastName) VALUES (?, ?) RETURNING userId" (firstName, lastName)
      case res of
        [Only userId] -> return $ User { userId = userId
                      , userLastName = lastName
                      , userFirstName = firstName
                      }
        _ -> error "asd"


listUsers :: ReaderT Database Handler [User]
listUsers = do
  Database{ pool } <- ask
  res :: [(Int, String, String)] <- liftIO $ withResource pool $ \conn -> query conn "SELECT * FROM users" ()
  return $ map (\(userId, firstName, lastName) -> User { userId = userId, userFirstName = firstName, userLastName = lastName }) res

-- getUser :: Int -> Handler User
-- getUser = undefined

-- updateUser :: Int -> Handler User
-- updateUser = undefined

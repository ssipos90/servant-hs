{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE NamedFieldPuns        #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeOperators         #-}

module Lib
    ( startApp
    ) where
import           Control.Monad.Reader                 (MonadIO (liftIO),
                                                       ReaderT (..), ask,
                                                       runReaderT)

import           Data.Aeson                           (FromJSON (parseJSON),
                                                       ToJSON (toJSON),
                                                       Value (String),
                                                       defaultOptions, object,
                                                       withText, (.=))
import           Data.Aeson.TH                        (deriveJSON)
import           Data.ByteString.Char8                (pack)
import           Data.Pool                            (Pool (..), createPool,
                                                       withResource)
import qualified Data.Text                            as T
import           Data.Text.Encoding                   (decodeUtf8)
import           Database.PostgreSQL.Simple           (ConnectInfo, Connection,
                                                       FromRow, In (In),
                                                       Only (Only), close,
                                                       connect, query)
import           Database.PostgreSQL.Simple.FromField (FromField (..),
                                                       ResultError (..),
                                                       returnError)
import           Database.PostgreSQL.Simple.Time      (LocalTimestamp)
import           Database.PostgreSQL.Simple.ToField   (Action (..),
                                                       ToField (..))
import           GHC.Generics                         (Generic (..))
import           Network.Wai
import           Network.Wai.Handler.Warp
import           Servant                              (Capture, Handler,
                                                       HasServer (ServerT),
                                                       Proxy (..), QueryParams,
                                                       ServerT, hoistServer,
                                                       serve)
import           Servant.API                          (Get, JSON, Post, ReqBody,
                                                       (:<|>) (..), (:>))

data User = User
  { userId        :: Int
  , userFirstName :: String
  , userLastName  :: String
  } deriving (Show)

instance Eq User where
  User {userId = userId1} == User {userId = userId2} = userId1 == userId2

data CreateUser = CreateUser
  { firstName :: String
  , lastName  :: String
  } deriving (Show, Generic)

data Account = Liability | Expense deriving (Show, Eq)


instance FromField Account where
  fromField f mData = case mData of
                        Just d -> case decodeUtf8 d of
                          "Liability" -> return Liability
                          "Expense" -> return Expense
                          s -> returnError ConversionFailed f $ T.unpack s
                        Nothing -> returnError Incompatible f ""

escapeShow :: Show a => a -> Action
escapeShow = Escape . pack . show

instance ToField Account where
  toField a = escapeShow a

data Transaction = Transaction
  { transactionId :: Int
  , fromUserId    :: Int
  , toUserId      :: Int
  , amount        :: Int
  , date          :: String
  , account       :: Account
  -- TODO: storno
  } deriving (Show, Generic, FromRow)

data AddTransaction = AddTransaction
  { fromUserId :: Int
  , toUserId   :: Int
  , amount     :: Int
  , account    :: Account
  } deriving (Generic)

instance FromJSON CreateUser

instance FromJSON Account where
  parseJSON = withText "Account" $ \case
      "Liability" -> return Liability
      "Expense"   -> return Expense
      _           -> fail "invalid account type"

instance ToJSON Account where
  toJSON = String . T.pack . show

instance FromJSON AddTransaction

instance ToJSON User where
  toJSON User { userId, userFirstName, userLastName } =
    object [ "userId" .= userId
           , "firstName" .= userFirstName
           , "lastName"  .= userLastName
           ]

$(deriveJSON defaultOptions ''Transaction)

{-
  CREATE TABLE IF NOT EXISTS users
  ( userId INT GENERATED BY DEFAULT AS IDENTITY
  , firstName VARCHAR NOT NULL
  , lastName VARCHAR NOT NULL
  , PRIMARY KEY(userId)
  );

  CREATE TYPE account AS ENUM ('Liability', 'Expense');

  CREATE TABLE IF NOT EXISTS transactions
  ( transactionId INT GENERATED BY DEFAULT AS IDENTITY
  , fromUserId INT NOT NULL
  , toUserId INT NOT NULL
  , amount INT NOT NULL
  , account account NOT NULL
  , date TIMESTAMP NOT NULL DEFAULT now()
  , PRIMARY KEY(transactionId)
  , CONSTRAINT fk_from_user
     FOREIGN KEY(fromUserId)
       REFERENCES users(userId)
  , CONSTRAINT fk_to_user
     FOREIGN KEY(toUserId)
       REFERENCES users(userId)
  );

  CREATE INDEX IF NOT EXISTS transaction_account_idx
  ON transactions
  (account);
-}

data AppConfig = AppConfig {
  pool :: Pool Connection
}

initConnectionPool :: ConnectInfo  -> IO (Pool Connection)
initConnectionPool connInfo =
  createPool (connect connInfo)
             close
             2 -- stripes
             60 -- unused connections are kept open for a minute
             10 -- max. 10 connections open per stripe


startApp :: ConnectInfo -> IO ()
startApp connInfo = do
  pool <- initConnectionPool connInfo
  run 8080 (app $ AppConfig { pool = pool })

app :: AppConfig -> Application
app db = serve api $ hoistServer api (readerToHandler db) server


type API =
          "users" :> (
              Get '[JSON] [User]
          :<|> ReqBody '[JSON] CreateUser :> Post '[JSON] User
          :<|> Capture "userId" Int :> (
                Get '[JSON] User
            :<|> "transactions" :> QueryParams"accounts" String :> Get '[JSON] [Transaction]
                )
        )
     :<|> "transactions" :> (
                Get '[JSON] [Transaction]
           :<|> ReqBody '[JSON] AddTransaction :> Post '[JSON] Transaction
          )


api :: Proxy API
api = Proxy


readerToHandler :: AppConfig -> ReaderT AppConfig Handler a -> Handler a
readerToHandler db r = runReaderT r db


server :: ServerT API (ReaderT AppConfig Handler)
server = (listUsers
  :<|> createUser
  :<|> (\userId ->
          showUser userId
     :<|> showUserTransactions userId
  ))
  :<|> (
         listTransactions
    :<|> addTransaction
    )


showUserTransactions :: Int -> [String] -> ReaderT AppConfig Handler [Transaction]
showUserTransactions userId accounts = do
  AppConfig{ pool } <- ask
  res :: [Transaction] <- liftIO $ withResource pool (\conn ->
      if null accounts then
        query conn "SELECT transactionId, fromUserId, toUserId, amount, date \
                   \FROM transactions \
                   \WHERE fromUserId=? OR toUserId=?"
          (userId, userId)
      else
        query conn "SELECT transactionId, fromUserId, toUserId, amount, date \
                  \FROM transactions \
                  \WHERE (fromUserId=? OR toUserId=?) AND account in ?"
          (userId, userId, In accounts)
    )
  return res

addTransaction :: AddTransaction -> ReaderT AppConfig Handler Transaction
addTransaction AddTransaction{ fromUserId, toUserId, amount, account }= do
  AppConfig{ pool } <- ask
  res :: [(Int, LocalTimestamp)] <- liftIO $ withResource pool (\conn ->
    query conn "INSERT INTO transactions (fromUserId, toUserId, amount, account) \
                                 \VALUES (?, ?, ?, ?) \
                                 \RETURNING transactionId, date"
      (fromUserId, toUserId, amount, account))
  case res of
    [(transactionId, date)] ->
      return Transaction { transactionId = transactionId
                         , fromUserId = fromUserId
                         , toUserId = toUserId
                         , amount = amount
                         , account = account
                         , date = show date
                         }
    _ -> error "Transaction failed"


listTransactions :: ReaderT AppConfig Handler [Transaction]
listTransactions = do
  AppConfig{ pool } <- ask
  res :: [Transaction] <- liftIO $ withResource pool (\conn ->
    query conn "SELECT * FROM transactions" ())
  return res

showUser :: Int -> ReaderT AppConfig Handler User
showUser userId = do
    AppConfig{ pool } <- ask
    res :: [(Int, String, String)] <- liftIO $ withResource pool (\conn -> query conn "SELECT * FROM users WHERE userId=? LIMIT 1" (Only userId))
    case res of
      [(_,firstName, lastName)] ->
        return $ User { userId = userId
                      , userFirstName = firstName
                      , userLastName = lastName
                      }
      _ -> error "User not found."


createUser :: CreateUser -> ReaderT AppConfig Handler User
createUser CreateUser{ firstName, lastName } = do
  AppConfig{ pool } <- ask
  res :: [Only Int] <- liftIO $ withResource pool $ \conn ->
    query conn "INSERT INTO users (firstName, lastName) VALUES (?, ?) RETURNING userId"
      (firstName, lastName)
  case res of
    [Only userId] -> return $ User
                  { userId = userId
                  , userLastName = lastName
                  , userFirstName = firstName
                  }
    _ -> error "IDK what happened."


listUsers :: ReaderT AppConfig Handler [User]
listUsers = do
  AppConfig{ pool } <- ask
  res :: [(Int, String, String)] <- liftIO $ withResource pool $ \conn ->
    query conn "SELECT * FROM users" ()
  return $ map (\(userId, firstName, lastName) ->
    User { userId = userId, userFirstName = firstName, userLastName = lastName }) res


-- getUser :: Int -> Handler User
-- getUser = undefined

-- updateUser :: Int -> Handler User
-- updateUser = undefined

{-# LANGUAGE DataKinds       #-}
{-# LANGUAGE DeriveGeneric   #-}
{-# LANGUAGE NamedFieldPuns  #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeOperators   #-}
{-# LANGUAGE ScopedTypeVariables   #-}

module Lib
    ( startApp
    ) where
import           Control.Monad              (forM_, forM)
import           Control.Monad.Reader       (MonadIO (liftIO), Reader (..), ask,
                                             asks, runReader)

import           Control.Exception          (bracket)
import           Data.Aeson                 (FromJSON (parseJSON),
                                             ToJSON (toJSON), Value (String),
                                             defaultOptions, fromJSON, withText)
import           Data.Aeson.TH              (deriveJSON)
import           Data.ByteString            (ByteString)
import           Data.Pool                  (Pool (..), createPool,
                                             withResource)
import           Database.PostgreSQL.Simple (Connection, Only (Only), close,
                                             connectPostgreSQL, execute_, query)
import           GHC.Generics               (Generic (..))
import           Network.Wai
import           Network.Wai.Handler.Warp
import           Servant                    (Capture, Handler,
                                             HasServer (ServerT), Proxy (..),
                                             Server, ServerT, hoistServer,
                                             serve)
import           Servant.API                (Get, JSON, Post, Put, ReqBody,
                                             (:<|>) (..), (:>))

type DBConnectionString = ByteString

data User = User
  { userId        :: Int
  , userFirstName :: String
  , userLastName  :: String
  } deriving (Eq, Show)

data CreateUser = CreateUser
  { firstName :: String
  , lastName  :: String
  } deriving (Show, Generic)

instance FromJSON CreateUser

$(deriveJSON defaultOptions ''User)

type API = "users" :> (
                        Get '[JSON] [User]
                   :<|> ReqBody '[JSON] CreateUser :> Post '[JSON] User
                      )
                  --  :<|> Capture "userId" Int :> (
                  --         Get '[JSON] User
                  --    :<|> Put '[JSON] User
                  --   )
                  -- )

initDB :: DBConnectionString -> IO ()
initDB connstr = bracket (connectPostgreSQL connstr) close $ \conn -> do
  execute_ conn
    "CREATE TABLE IF NOT EXISTS messages (msg text not null)"
  execute_ conn
    "CREATE TABLE IF NOT EXISTS users \
    \( userId INT GENERATED BY DEFAULT AS IDENTITY\
    \, firstName VARCHAR NOT NULL\
    \, lastName VARCHAR NOT NULL\
    \)"
  return ()

data Database = Database {
  pool :: Pool Connection
}

initConnectionPool :: DBConnectionString -> IO (Pool Connection)
initConnectionPool connStr =
  createPool (connectPostgreSQL connStr)
             close
             2 -- stripes
             60 -- unused connections are kept open for a minute
             10 -- max. 10 connections open per stripe

startApp :: IO ()
startApp = do
  let connStr = "host=localhost port=5432 dbname=mydb user=postgres password=1q2w3e"
  pool <- initConnectionPool connStr
  initDB connStr
  run 8080 $ app $ Database { pool = pool }
  return ()

app :: Database -> Application
app db = serve api $ hoistServer api (readerToHandler db) server

api :: Proxy API
api = Proxy

readerToHandler :: Database -> Reader Database a -> Handler a
readerToHandler db r = return $ runReader r db

server :: ServerT API (Reader Database)
server = listUsers
        :<|> createUser
        -- :<|> (\userId ->
        --         getUser userId
        --         :<|> updateUser userId
        --       )
listUsers :: Reader Database [User]
listUsers = do
  Database{ pool } <- ask
  -- run query
  return []

createUser :: CreateUser -> Reader Database User
createUser CreateUser{ firstName, lastName } = do
                                      Database{ pool } <- ask
                                      res :: [Only Int] <- liftIO $ withResource pool $ \conn -> query conn "INSERT INTO users (firstName, lastName) VALUES (?, ?) RETURNING userId" (firstName, lastName)
                                      return $ User { userId = 123
                                                      , userLastName = lastName
                                                      , userFirstName = firstName
                                                      }

getUser :: Int -> Handler User
getUser = undefined

updateUser :: Int -> Handler User
updateUser = undefined

users :: [User]
users = [ User 1 "Isaac" "Newton"
        , User 2 "Albert" "Einstein"
        ]
